---
title: 开发规范
des: 后端规范1.0.1
date: 2021-05-27
author: wang Q
tags:
    - 后端
    - 规范
group: specification
---

# 文档修订记录

| 版本号 | 维护时间   | 维护人 | 状态 | 操作说明     |
| ------ | ---------- | ------ | ---- | ------------ |
| v 0.1  | 2020-11-17 | wang Q | C    | 初始化文档   |
| v 1.0  | 2020-11-18 | wang Q | A    | 文档初版发布 |
|        |            |        |      |              |
|        |            |        |      |              |
|        |            |        |      |              |
|        |            |        |      |              |
|        |            |        |      |              |
|        |            |        |      |              |

# 1. 编码规范

## 1.1 命名风格

> 【强制】代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。

```
反例：_name / __name / $name / name_ / name$ / name__
```

> 【强制】所有编程相关的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。

说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，纯拼音命名方式更要避免采用。

```
正例：ali / alibaba / taobao / cainiao/ aliyun/ youku / hangzhou 等国际通用的名称，可视同英文。
反例：DaZhePromotion [打折] / getPingfenByName() [评分] / int 某变量 = 3
```

> 【强制】类名使用 UpperCamelCase 风格

```
正例：ForceCode
反例：forcecode
```

> 【强制】方法名、参数名、成员变量、局部变量、JSP 文件名都统一使用 lowerCamelCase 风格。

```
正例： localValue / getHttpMessage() / inputUserId
```

> 【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。

```
正例：MAX_STOCK_COUNT / CACHE_EXPIRED_TIME
```

> 【强制】抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾。

> 【强制】类型与中括号紧挨相连来表示数组。

```
正例：定义整形数组 int[] arrayDemo;
反例：在 main 参数中，使用 String args[]来定义
```

> 【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。

> 【强制】避免在子父类的成员变量之间、或者不同代码块的局部变量之间采用完全相同的命名，使可读性降低。

说明：子类、父类成员变量名相同，即使是 public 类型的变量也是能够通过编译，而局部变量在同一方法内的不同代码块中同名也是合法的，但是要避免使用。对于非 setter/getter 的参数名称也要避免与成员变量名称相同。

```
反例：
public class ConfusingName {
	public int stock;
	// 非 setter/getter 的参数名称，不允许与本类成员变量同名
	public void get(String alibaba) {
		if (condition) {
			final int money = 666;
			// ...
		}
		for (int i = 0; i < 10; i++) {
			// 在同一方法体中，不允许与其它代码块中的 money 命名相同
			final int money = 15978;
			// ...
		}
	}
}
class Son extends ConfusingName {
	// 不允许与父类的成员变量名称相同
	public int stock;
}
```

> 【推荐】为了达到代码自解释的目标，任何自定义编程元素在命名时，使用尽量完整的单词组合来表达。

```
正例：在 JDK 中，对某个对象引用的 volatile 字段进行原子更新的类名为：AtomicReferenceFieldUpdater。
反例：常见的方法内变量为 int a;的定义方式。
```

> 【推荐】在常量与变量的命名时，表示类型的名词放在词尾，以提升辨识度。

```
正例：startTime / workQueue / nameList / TERMINATED_THREAD_COUNT
反例：startedAt / QueueOfWork / listName / COUNT_TERMINATED_THREAD
```

> 【推荐】平台中存在部分固定的类名后缀，推荐大家遵循。

```
...Edit : 编辑表单页面后缀
...Page : 普通页面
...Upload： 文件上传类
...Converter : 服务报文转换后缀
...Helper: 资源报文转换后缀
...Handler: TCP报文转换
...Service：http通讯上层入口Servlet
...Node：节点类（存在文档的情况一般和文档接口标识统一）
...Auto/Timer: 定时任务类
```

## 1.2 常量定义

> 【强制】在 long 或者 Long 赋值时，数值后使用大写的 L，不能是小写的 l，小写容易跟数字混淆，造成误解。

说明：Long a = 2l; 写的是数字的 21，还是 Long 型的 2。

> 【推荐】不要使用一个常量类维护所有常量，要按常量功能进行归类，分开维护。

说明：大而全的常量类，杂乱无章，使用查找功能才能定位到修改的常量，不利于理解，也不利于维护。

```
正例：缓存相关常量放在类 CacheConsts 下；系统配置相关常量放在类 ConfigConsts 下
```

## 1.3 代码格式

> 【强制】如果是大括号内为空，则简洁地写成{}即可，大括号中间无需换行和空格；如果是非空代码块则：

1） 左大括号前不换行。
2） 左大括号后换行。
3） 右大括号前换行。
4） 右大括号后还有 else 等代码则不换行；表示终止的右大括号后必须换行。

> 【强制】左小括号和右边相邻字符之间不出现空格 ； 右小括号和左边相邻字符之间也不出现空格；而左大括号前需要加空格。详见第 5 条下方正例提示。

反例：if (空格 a == b 空格)

> 【强制】if/for/while/switch/do 等保留字与括号之间都必须加空格。

> 【强制】任何二目、三目运算符的左右两边都需要加一个空格。

说明：包括赋值运算符=、逻辑运算符&&、加减乘除符号等。

> 【强制】注释的双斜线与注释内容之间有且仅有一个空格。

```
正例：
// 这是示例注释，请注意在双斜线之后有一个空格
String commentString = new String();
```

> 【强制】在进行类型强制转换时，右括号与强制转换值之间不需要任何空格隔开。

```
正例：
long first = 1000000000000L;
int second = (int)first + 2;
```

> 【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。

```
正例：下例中实参的 args1，后边必须要有一个空格。
method(args1, args2, args3);
```

> 【强制】IDE 的 text file encoding 设置为 UTF-8; IDE 中文件的换行符使用 Unix 格式，不要使用 Windows 格式。

> 【推荐】单个方法的总行数不超过 80 行。

说明：除注释之外的方法签名、左右大括号、方法内代码、空行、回车及任何不可见字符的总行数不超过 80 行。

```
正例：代码逻辑分清红花和绿叶，个性和共性，绿叶逻辑单独出来成为额外方法，使主干代码更加清晰；共性逻辑抽取成为共性方法，便于复用和维护。
```

> 【推荐】没有必要增加若干空格来使变量的赋值等号与上一行对应位置的等号对齐。

```
正例：
int one = 1;
long two = 2L;
float three = 3F;
StringBuilder sb = new StringBuilder();
说明：增加 sb 这个变量，如果需要对齐，则给 one、two、three 都要增加几个空格，在变量比较多的情况下，是非常累赘的事情。
```

> 【推荐】不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开来以提升可读性。

说明：任何情形，没有必要插入多个空行进行隔开。

## 1.4 OOP 规范

> 【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。

> 【强制】所有的覆写方法，必须加@ Override 注解。

说明：getObject()与 get0bject()的问题。一个是字母的 O，一个是数字的 0，加@Override 可以准确判
断是否覆盖成功。另外，如果在抽象类中对方法签名进行修改，其实现类会马上编译报错。

> 【强制】相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object 。

说明：可变参数必须放置在参数列表的最后。（提倡同学们尽量不用可变参数编程）

```
正例：public List<User> listUsers(String type, Long... ids) {...}
```

> 【强制】不能使用过时的类或方法。

说明：java.net.URLDecoder 中的方法 decode(String encodeStr) 这个方法已经过时，应该使用双参数
decode(String source, String encode)。接口提供方既然明确是过时接口，那么有义务同时提供新的接口；
作为调用方来说，有义务去考证过时方法的新实现是什么。

> 【强制】 Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals 。

```
正例："test".equals(object);
反例：object.equals("test");
```

> 【强制】所有整型包装类对象之间值的比较，全部使用 equals 方法比较。

说明：对于 Integer var = ? 在-128 至 127 之间的赋值，Integer 对象是在 IntegerCache.cache 产生，会复用已有对象，这个区间内的 Integer 值可以直接使用==进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用 equals 方法进行判断。

> 【强制】定义数据对象 DO 类时，属性类型要与数据库字段类型相匹配。

```
正例：数据库字段的 bigint 必须与类属性的 Long 类型相对应。
反例：某个案例的数据库表 id 字段定义类型 bigint unsigned，实际类对象属性为 Integer，随着 id 越来
越大，超过 Integer 的表示范围而溢出成为负数。
```

> 【强制】序列化类新增属性时，请不要修改 serialVersionUID 字段，避免反序列失败；如果完全不兼容升级，避免反序列化混乱，那么请修改 serialVersionUID 值。

说明：注意 serialVersionUID 不一致会抛出序列化运行时异常。

> 【强制】POJO 类必须写 toString 方法。使用 IDE 中的工具：source> generate toString 时，如果继承了另一个 POJO 类，注意在前面加一下 super.toString。

说明：在方法执行抛出异常时，可以直接调用 POJO 的 toString()方法打印其属性值，便于排查问题。

> 【强制】禁止在 POJO 类中，同时存在对应属性 xxx 的 isXxx()和 getXxx()方法。

说明：框架在调用属性 xxx 的提取方法时，并不能确定哪个方法一定是被优先调用到，神坑之一

> 【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读，此条规则优先于下一条。

> 【推荐】 类内方法定义的顺序依次是：公有方法或保护方法 > 私有方法 > getter / setter 方法。

说明：公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个黑盒实现；因为承载的信息价值较低，所有 Service 和 DAO 的 getter/setter 方法放在类体最后。

> 【推荐】循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展。

说明：下例中，反编译出的字节码文件显示每次循环都会 new 出一个 StringBuilder 对象，然后进行 append 操作，最后通过 toString 方法返回 String 对象，造成内存资源浪费。

```
反例：
String str = "start";
for (int i = 0; i < 100; i++) {
	str = str + "hello";
}
```

> 【推荐】 final 可以声明类、成员变量、方法、以及本地变量，下列情况使用 final 关键字：

1） 不允许被继承的类，如：String 类。
2） 不允许修改引用的域对象，如：POJO 类的域变量。
3） 不允许被覆写的方法，如：POJO 类的 setter 方法。
4） 不允许运行过程中重新赋值的局部变量。
5） 避免上下文重复使用一个变量，使用 final 可以强制重新定义一个变量，方便更好地进行重构。

> 【推荐】慎用 Object 的 clone 方法来拷贝对象。

说明：对象 clone 方法默认是浅拷贝，若想实现深拷贝需覆写 clone 方法实现域对象的深度遍历式拷贝

> 【推荐】类成员与方法访问控制从严：

1） 如果不允许外部直接通过 new 来创建对象，那么构造方法必须是 private。
2） 工具类不允许有 public 或 default 构造方法。
3） 类非 static 成员变量并且与子类共享，必须是 protected。
4） 类非 static 成员变量并且仅在本类使用，必须是 private。
5） 类 static 成员变量如果仅在本类使用，必须是 private。
6） 若是 static 成员变量，考虑是否为 final。
7） 类成员方法只供类内部调用，必须是 private。
8） 类成员方法只对继承类公开，那么限制为 protected。
说明：任何类、方法、参数、变量，严控访问范围。过于宽泛的访问范围，不利于模块解耦

## 1.5 日期时间

> 【强制】日期格式化时，传入 pattern 中表示年份统一使用小写的 y。

说明：日期格式化时，yyyy 表示当天所在的年，而大写的 YYYY 代表是 week in which year（JDK7 之后引入的概念），意思是当天所在的周属于的年份，一周从周日开始，周六结束，只要本周跨年，返回的 YYYY 就是下一年。

> 【强制】在日期格式中分清楚大写的 M 和小写的 m，大写的 H 和小写的 h 分别指代的意义。

说明：日期格式中的这两对字母表意如下：
1） 表示月份是大写的 M；
2） 表示分钟则是小写的 m；
3） 24 小时制的是大写的 H；
4） 12 小时制的则是小写的 h。

> 【强制】获取当前毫秒数：System.currentTimeMillis(); 而不是 new Date().getTime()。

> 【强制】不要在程序中写死一年为 365 天，避免在公历闰年时出现日期转换错误或程序逻辑错误。

> 【推荐】避免公历闰年 2 月问题。闰年的 2 月份有 29 天，一年后的那一天不可能是 2 月 29 日。

> 【推荐】使用枚举值来指代月份。如果使用数字，注意 Date，Calendar 等日期相关类的月份 month 取值在 0-11 之间。

## 1.6 集合处理

> 【强制】判断所有集合内部的元素是否为空，使用 isEmpty()方法，而不是 size()==0 的方式。

说明：前者的时间复杂度低，而且可读性更好。

```
正例：
Map<String, Object> map = new HashMap<>();
if(map.isEmpty()) {
	System.out.println("no element in this map.");
}
```

> 【强制】使用 Map 的方法 keySet() / values() / entrySet() 返回集合对象时，不可以对其进行添加元素操作，否则会抛出 UnsupportedOperationException 异常。

> 【强制】不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator 方式，如果并发操作，需要对 Iterator 对象加锁。

```
正例：
List<String> list = new ArrayList<>();
list.add("1");
list.add("2");
Iterator<String> iterator = list.iterator();
while (iterator.hasNext()) {
	String item = iterator.next();
	if (删除元素的条件) {
		iterator.remove();
	}
}

反例：
for (String item : list) {
	if ("1".equals(item)) {
		list.remove(item);
	}
}
```

## 1.7 并发处理

> 【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。

说明：Executors 返回的线程池对象的弊端如下：
1） FixedThreadPool 和 SingleThreadPool：
允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。
2） CachedThreadPool：
允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。

> 【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁 ； 能锁区块，就不要锁整个方法体 ； 能用对象锁，就不要用类锁。

说明：尽可能使加锁的代码块工作量尽可能的小，避免在锁代码块中调用 RPC 方法。

> 【推荐】避免 Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一 seed 导致的性能下降。

说明：Random 实例包括 java.util.Random 的实例或者 Math.random()的方式。
正例：在 JDK7 之后，可以直接使用 API ThreadLocalRandom，而在 JDK7 之前，需要编码保证每个线
程持有一个单独的 Random 实例

## 1.8 控制语句

> 【强制】在一个 switch 块内，每个 case 要么通过 continue/break/return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止；在一个 switch 块内，都必须包含一个 default 语句并且放在最后，即使它什么代码也没有。

说明：注意 break 是退出 switch 语句块，而 return 是退出方法体。

> 【强制】在 if / else / for / while / do 语句中必须使用大括号。

说明：即使只有一行代码，禁止不采用大括号的编码方式：if (condition) statements;

> 【强制】三目运算符 condition? 表达式 1 : 表达式 2 中，高度注意表达式 1 和 2 在类型对齐时，可能抛出因自动拆箱导致的 NPE 异常。

说明：以下两种场景会触发类型对齐的拆箱操作：
1） 表达式 1 或表达式 2 的值只要有一个是原始类型。
2） 表达式 1 或表达式 2 的值的类型不一致，会强制拆箱升级成表示范围更大的那个类型。

```
反例：
Integer a = 1;
Integer b = 2;
Integer c = null;
Boolean flag = false;
// a*b 的结果是 int 类型，那么 c 会强制拆箱成 int 类型，抛出 NPE 异常
Integer result=(flag? a*b : c);
```

> 【强制】在高并发场景中，避免使用”等于”判断作为中断或退出的条件。

说明：如果并发控制没有处理好，容易产生等值判断被“击穿”的情况，使用大于或小于的区间判断条件
来代替。

```
反例：判断剩余奖品数量等于 0 时，终止发放奖品，但因为并发处理错误导致奖品数量瞬间变成了负数，
这样的话，活动无法终止。
```

> 【推荐】当某个方法的代码行数超过 10 行时，return / throw 等中断逻辑的右大括号后加一
> 个空行。

说明：这样做逻辑清晰，有利于代码阅读时重点关注。

> 【推荐】除常用方法（如 getXxx/isXxx ）等外，不要在条件判断中执行其它复杂的语句，将复
> 杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。

说明：很多 if 语句内的逻辑表达式相当复杂，与、或、取反混合运算，甚至各种方法纵深调用，理解成本
非常高。如果赋值一个非常好理解的布尔变量名字，则是件令人爽心悦目的事情。

```
正例：
// 伪代码如下
final boolean existed = (file.open(fileName, "w") != null) && (...) || (...);
if (existed) {
	...
}

反例：
public final void acquire ( long arg){
	if (!tryAcquire(arg) &&
		acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) {
		selfInterrupt();
	}

}
```

> 【推荐】避免采用取反逻辑运算符。

说明：取反逻辑不利于快速理解，并且取反逻辑写法必然存在对应的正向逻辑写法。

```
正例：使用 if (x < 628) 来表达 x 小于 628。
反例：使用 if (!(x >= 628)) 来表达 x 小于 628。
```

> 【推荐】接口入参保护，这种场景常见的是用作批量操作的接口。

```
反例：某业务系统，提供一个用户批量查询的接口，API 文档上有说最多查多少个，但接口实现上没做任何
保护，导致调用方传了一个 1000 的用户 id 数组过来后，查询信息后，内存爆了。
```

> 【参考】下列情形，需要进行参数校验：

1） 调用频次低的方法。
2） 执行时间开销很大的方法。此情形中，参数校验时间几乎可以忽略不计，但如果因为参数错误导致
中间执行回退，或者错误，那得不偿失。
3） 需要极高稳定性和可用性的方法。
4） 对外提供的开放接口，不管是 RPC/API/HTTP 接口。
5） 敏感权限入口。

> 【参考】下列情形，不需要进行参数校验：

1） 极有可能被循环调用的方法。但在方法说明里必须注明外部参数检查。
2） 底层调用频度比较高的方法。毕竟是像纯净水过滤的最后一道，参数错误不太可能到底层才会暴露
问题。一般 DAO 层与 Service 层都在同一个应用中，部署在同一台服务器中，所以 DAO 的参数校验，可
以省略。
3） 被声明成 private 只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参数已经做过检
查或者肯定不会有问题，此时可以不校验参数

## 1.9 注释规约

> 【强制】类、类属性、类方法的注释必须使用 Javadoc 规范，使用/\*_内容_/格式，不得使用// xxx 方式。

说明：在 IDE 编辑窗口中，Javadoc 方式会提示相关注释，生成 Javadoc 可以正确输出相应注释；在 IDE
中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高阅读效率。

> 【强制】所有的抽象方法 （ 包括接口中的方法 ） 必须要用 Javadoc 注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。

说明：对子类的实现要求，或者调用注意事项，请一并说明。

> 【强制】所有的类都必须添加创建者和创建日期。

说明：在设置模板时，注意 IDEA 的@author 为`${USER}`，而 eclipse 的@author 为`${user}`，大小写有区别。

```
正例：
/**
@author yangguanbao
@date 2016/10/31
*/
```

> 【强制】方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释使用/\* \*/注释，注意与代码对齐。

> 【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。

> 【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。

反例：“TCP 连接超时”解释成“传输控制协议连接超时”，理解反而费脑筋。

> 【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。

说明：代码与注释更新不同步，就像路网与导航软件更新不同步一样，如果导航软件严重滞后，就失去了
导航的意义。

> 【推荐】在类中删除未使用的任何字段和方法；在方法中删除未使用的任何参数声明与内部变量。

> 【参考】谨慎注释掉代码。在上方详细说明，而不是简单地注释掉。如果无用，则删除。

说明：代码被注释掉有两种可能性：1）后续会恢复此段代码逻辑。2）永久不用。前者如果没有备注信息，
难以知晓注释动机。后者建议直接删掉即可，假如需要查阅历史代码，登录代码仓库即可。

> 【参考】对于注释的要求：第一、能够准确反映设计思想和代码逻辑 ； 第二、能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路 ； 注释也是给继任者看的，使其能够快速接替自己的工作。

> 【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担。

```
反例：
// put elephant into fridge
put(elephant, fridge);
方法名 put，加上两个有意义的变量名 elephant 和 fridge，已经说明了这是在干什么，语义清晰的代码不
需要额外的注释。
```

## 1.10 前端规范

> 【强制】jsp 文件名使用大驼峰命名法，首字母大写

> 【强制】 js、css、html 文件名不得含有空格，当文件名包含多个单词时，单词之间应使用半角连词线(-)分隔

> 【强制】变量命名应以小驼峰式命名方法，如没明确类型，应以前缀为名词。

> 【强制】函数命名应以小驼峰式命名方法，前缀为动词。回调方法除外。

> 【强制】常量命名应以大写字母和下划线来组合命名，下划线用以分割单词

> 【强制】html 中 id 及 classname 命名方式以小驼峰命名为主，并用半角连词线(-)分隔，具体以实际情况为准

> 【强制】 单行注释写法：//(双斜线)与注释文字间保留一个空格。

> 【强制】函数注释以多行注释/\* \*/为主，以项目具体情况选择使用。

> 【强制】js、css 注释方式统一使用双斜线//进行单行注释

## 1.11 其他

> 【强制】注意 Math . random() 这个方法返回是 double 类型，注意取值的范围 0≤ x <1 （ 能够取到零值，注意除零异常 ） ，如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后取整，直接使用 Random 对象的 nextInt 或者 nextLong 方法。

> 【强制】使用单独的数据库连接，永远使用即用即取的原则，禁止将连接成员变量化、局部变量化甚至静态化的处理。

说明：默认数据库连接与线程绑定，一旦成员变量化处理后，出现跨线程的情况，就出现连接已关闭的情况。局部变量化后，如果自己未注意手动关闭了连接，后续再使用该连接也会出现问题，所以，在需要数据库连接的时候，建议直接使用 DBFactory.getActionDB 或者 this.getDBManager 进行获取。

> 【推荐】及时清理不再使用的代码段或配置信息。

说明：对于垃圾代码或过时配置，坚决清理干净，避免程序过度臃肿，代码冗余。

```
正例：对于暂时被注释掉，后续可能恢复使用的代码片断，在注释代码上方，统一规定使用三个斜杠(///)
来说明注释掉代码的理由。如：

public static void hello() {
	/// 业务方通知活动暂停
	// Business business = new Business();
	// business.active();
	System.out.println("it's finished");
}
```

# 2. 异常日志

## 2.1 异常处理

> 【强制】Java 类库中定义的可以通过预检查方式规避的 RuntimeException 异常不应该通过 catch 的方式来处理，比如：NullPointerException，IndexOutOfBoundsException 等等。

说明：无法通过预检查的异常除外，比如，在解析字符串形式的数字时，可能存在数字格式错误，不得不
通过 catch NumberFormatException 来实现。

```
正例：if (obj != null) {...}
反例：try { obj.method(); } catch (NullPointerException e) {…}
```

> 【强制】捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。

> 【强制】finally 块必须对资源对象、流对象进行关闭，有异常也要做 try-catch。

> 【强制】不要在 finally 块中使用 return。

说明：try 块中的 return 语句执行成功后，并不马上返回，而是继续执行 finally 块中的语句，如果此处存
在 return 语句，则在此直接返回，无情丢弃掉 try 块中的返回点。

```
反例：
private int x = 0;
public int checkReturn() {
	try {
		// x 等于 1，此处不返回
		return ++x;
	} finally {
		// 返回的结果是 2
		return ++x;
	}
}
```

> 【强制】在调用 RPC、二方包、或动态生成类的相关方法时，捕捉异常必须使用 Throwable 类来进行拦截。

说明：通过反射机制来调用方法，如果找不到方法，抛出 NoSuchMethodException。什么情况会抛出
NoSuchMethodError 呢？二方包在类冲突时，仲裁机制可能导致引入非预期的版本使类的方法签名不匹配，
或者在字节码修改框架（比如：ASM）动态创建或修改类时，修改了相应的方法签名。这些情况，即使代
码编译期是正确的，但在代码运行期时，会抛出 NoSuchMethodError。

> 【推荐】方法的返回值可以为 null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回 null 值。

说明：本手册明确防止 NPE 是调用者的责任。即使被调用方法返回空集合或者空对象，对调用者来说，也
并非高枕无忧，必须考虑到远程调用失败、序列化失败、运行时异常等场景返回 null 的情况。

## 2.2 日志规约

> 【强制】应用中不可直接使用日志系统 （Log 4 j 、 Logback） 中的 API ，而应使用平台日志处理，有利于维护和各个类的日志处理方式统一。

> 【强制】生产环境禁止直接使用 System.out 或 System.err 输出日志或使用 e.printStackTrace()打印异常堆栈。

在测试完成项目后请及时进行清理

> 【强制】异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字 throws 往上抛出。

```
正例：this.log().error(各类参数或者对象 toString() + "_" + e.getMessage(), e);
```

> 【推荐】谨慎地记录日志。生产环境禁止输出 debug 日志 ； 有选择地输出 info 日志 ； 如果使用 warn 来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘撑爆，并记得及时删除这些观察日志。

说明：大量地输出无效日志，不利于系统性能提升，也不利于快速定位错误点。记录日志时请思考：这些
日志真的有人看吗？看到这条日志你能做什么？能不能给问题排查带来好处？

> 【推荐】可以使用 warn 日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。如非必要，请不要在此场景打出 error 级别，避免频繁报警。

说明：注意日志输出的级别，error 级别只记录系统逻辑出错、异常或者重要的错误信息。

# 3. 数据库

## 3.1 建表规约

> 【强制】表名、字段名必须使用大写字母或数字 ， 禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。

说明：DB2、Oracle 等数据库在名称中有小写字母的情况下，字段前后会自动添加双引号，查询的时候需要使用双引号查询，mysql 数据库没有这部分限制，windows 下 mysql 不区分大小写，linux 下 mysql 大小写敏感，为了统一处理，兼容全部的情况，全表名与全字段大写处理。（这里排除后续出现的 greenplumn 与 postgresql，因为这部分数据库的规则正好相反）

```
正例：PW_OPER，OP3_ID，LEVEL3_NAME
反例：PwOper，op3ID，LEVEL_3_NAME
```

> 【强制】所有表名前面都必须补充前缀来区分不同项目的定义表

```
例如：平台表 PT_ 开头，门户表 PW_开始
```

> 【强制】衍生类的表名可以在原始表名后补充固定后缀作为新表名

```
_T：衍生临时表
_H：衍生历史表
_E：衍生异常表
_B：衍生备份表
```

> 【强制】禁用保留字与关键字定义表名和列名，如 desc、range、match、delayed 等，

> 【强制】主键索引名为 pk* 字段名；唯一索引名为 uk *字段名 ； 普通索引名则为 idx \_字段名。

说明：pk* 即 primary key；uk* 即 unique key；idx\_ 即 index 的简称。

> 【强制】小数类型为 decimal，禁止使用 float 和 double。

说明：在存储的时候，float 和 double 都存在精度损失的问题，很可能在比较值的时候，得到不正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数并分开存储。另外，decimal 类型在 oracle、db2、mysql 这些项目常用数据都支持，出现数据库迁移的情况容易处理。

> 【强制】如果存储的字符串长度几乎相等，使用 char 定长字符串类型。

> 【强制】 varchar 是可变长字符串，不预先分配存储空间，长度不要超过 4000

说明：db2 数据库默认全表长度不能超过 8000，没有改过默认值的话请注意

> 【强制】表必备 id, create_date、edit_date、create_oper 为可选字段，推荐添加

说明：其中 id 必为主键，create_date 存储添加记录时间，edit_date 存储修改记录时间，create_oper 存储添加人。

> 【推荐】库名与应用名称尽量一致。

> 【推荐】字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循：

1） 不是频繁修改的字段。
2） 不是唯一索引的字段。
3） 不是 varchar 超长字段，更不能是 text 字段

> 【推荐】建表字段名称与数据库名称尽可能不要使用单名词，这样可以回避关键字问题

> 【推荐】单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。

说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。

## 3.2 索引规约

> 【强制】业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。

说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，
即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。

> 【推荐】如果有 order by 的场景，请注意利用索引的有序性。order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能。

```
正例：where a=? and b=? order by c; 索引：a_b_c
反例：索引如果存在范围查询，那么索引有序性无法利用，如：WHERE a>10 ORDER BY b; 索引 a_b 无
法排序
```

【推荐】建组合索引的时候，区分度最高的在最左边。

```
正例：如果 where a=? and b=?，a 列的几乎接近于唯一值，那么只需要单建 idx_a 索引即可。
说明：存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如：where c>? and d=?
那么即使 c 的区分度更高，也必须把 d 放在索引的最前列，即建立组合索引 idx_d_c。
```

> 【推荐】防止因字段类型不同造成的隐式转换，导致索引失效。

> 【推荐】超过三个表尽量不要使用 join 。需要 join 的字段，数据类型保持绝对一致 ； 多表关联查询时，保证被关联的字段需要有索引。

说明：即使双表 join 也要注意表索引、SQL 性能。

## 3.3 SQL 语句

> 【强制】不要使用 count(列名)或 count(常量)来替代 count(_)，count(_)是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。

说明：count(\*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。

> 【强制】count(distinct col) 计算该列除 NULL 之外的不重复行数，注意 count(distinct col1,col2) 如果其中一列全为 NULL，那么即使另一列有不同的值，也返回为 0。

> 【强制】表别名、字段别名严禁使用中文

> 【强制】当某一列的值全是 NULL 时，count(col)的返回结果为 0，但 sum(col)的返回结果为 NULL，因此使用 sum()时需注意 NPE 问题。

> 【强制】不得使用外键与级联，一切外键概念必须在应用层解决。

说明：（概念解释）学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学
生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于单机
低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库
的插入速度。

> 【强制】对于数据库中表记录的查询和变更，只要涉及多个表，都需要在列名前加表的别名（或表名）进行限定。

说明：对多表进行查询记录、更新记录、删除记录时，如果对操作列没有限定表的别名（或表名），并且操作列在多个表中存在时，就会抛异常。

```
正例：select t1.name from table_first as t1 , table_second as t2 where t1.id=t2.id;
反例：在某业务中，由于多表关联查询语句没有加表的别名（或表名）的限制，正常运行两年后，最近在
某个表中增加一个同名字段，在预发布环境做数据库变更后，线上查询语句出现出 1052 异常：Column
'name' in field list is ambiguous。
```

> 【强制】SQL 表名前必须添加 schema 信息，需要引入配置信息使用\${schema}.进行占位。

```
正例：select * from ${schema}.PW_OPER
```

> 【强制】数据库字段中包含日期型字段时，查询该字段的情况必须进行格式化处理，严禁日期信息中出现毫秒值

说明：db2、oracle 使用 to_char([字段名称],'yyyy-mm-dd hh24:mi:ss')，mysql 使用 date_format([字段名], '%Y-%c-%d %h:%i:%s' )

> 【推荐】SQL 语句中表的别名前加 as，并且以 t1、t2、t3、...的顺序依次命名。

说明：

1）别名可以是表的简称，或者是根据表出现的顺序，以 t1、t2、t3 的方式命名。

2）别名前加 as 使别名更容易识别。

```
正例：select t1.name from table_first as t1, table_second as t2 where t1.id=t2.id;
```

> 【推荐】 in 操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控制在 1000 个之内

> 【推荐】不推荐使用存储过程，存储过程难以调试和扩展，更没有移植性。

> 【推荐】 SQL 语句书写时，尽量保证表名、字段名大写，关键字信息小写，注意好换行处理。

说明：基于规范写出的 sql 便于读写。

# 4. 项目相关

## 4.1 代码结构

> 【强制】项目 SRC 下约定好的建包结构如下

kora.[项目名].dao：DAO 存储路径

kora.[项目名].web：内管上层包

kora.[项目名].esb：交易上层包

kora.[项目名].esb.node：实现节点上层包

kora.[项目名].esb.msg：报文转换类处理包

kora.[项目名].esb.servlet：servlet 处理包

kora.[项目名].auto：定时任务上层包

kora.[项目名].util：工具上层包

kora.[项目名].consts：常量上层包

> 【强制】JSP 页面统一存放上层位置为： /UI/[项目名]/

> 【强制】内管研发代码存放遵循 kora.[项目名].web.[模块包].[菜单包].页面类 的位置存放，对应页面存放也遵循 /UI/[项目名]/[模块]/[菜单]/页面 JSP 的路径存放

> 【强制】项目统一设置 UTF-8 编码

> 【推荐】 内管研发，菜单包下的类超过 4 个以上，建议按照页面的关联与定义拆分子包处理，菜单入口页面必须放到菜单包下，关联页面可以按照功能不同、位置不同定义子包

> 【推荐】交易研发推荐类在 node 包下定义，可定义子包，但类名建议与交易文档中交易标识统一，便于后期项目定位问题。

## 4.2 内管研发

> 【强制】所有后台组件声明标识尽量保证全工程唯一性，无法保证的情况下，也要保证从菜单入口包向下全部类中的唯一性（平台固定标识不在其中）

说明：在 Copy 代码修改的时候，很多人不修改标识，新主题采用的是单页面刷新的模式，页面刷新的时候只刷新部分结构，同名标识的组件，前端控件的方法和属性会相互覆盖，如果定义了回调方法，就很容易相互影响，造成很多不易查询的错误。

> 【强制】页面通用组件标识请遵循下面规范

| 组件                     | 规范                                                   |
| ------------------------ | ------------------------------------------------------ |
| 顶层页面组件             | lowerCamelCase 定义，结尾补充组件类型（例如：xxxTree） |
| 表单组件（映射数据字典） | 全大写定义，与数据字典同名                             |
| 表单组件（普通定义）     | lowerCamelCase 定义，结尾补充组件类型（例如：xxxDrop） |
| 表格标题                 | 全大写定义（单表或报表）                               |
| URL 参数                 | lowerCamelCase 定义                                    |
|                          |                                                        |
|                          |                                                        |

> 【推荐】在平台组件无法满足的情况下，允许项目使用 JQuery 等外部组件进行个性化处理。实现功能后，建议通知技术部考虑是否在上层提供接口支持。

说明：项目中使用原生部分写法越多，未来如果要切换版本或者切换主题的难度就越大，固定统一 API 调用可以保证在切换的时候功能依然可以兼容使用，个性化过强的情况，未来基本只能重写处理，在目前平台版本切换的过程中尤其注意。

## 4.3 交易研发

> 【强制】交易与定时任务，如果涉及大量数据操作，请关闭数据库事务。

说明：默认平台交易与定时任务存在数据库事务控制，但是如果操作的数据量过多，最后提交的时候，很容易出现事务日志已满的情况，为了回避这种情况，涉及到大数据量操作的情况，请关闭事务控制。关闭的方法比较简单，最开始的位置调用一次数据库提交即可（DBFactory.getActionDB.commit）

> 【推荐】 交易研发中节点类名推荐与接口文档接口标识统一，便于后期管理

> 【推荐】H5 交易与对外提供的服务建议区分处理，H5 交易采用单配置方式处理（所有交易对应一条配置信息），方便后期功能调整（在 v3 注解模式支持后，可基于注解处理），对外服务采用多配置方法，每个服务对应各自的配置信息。
